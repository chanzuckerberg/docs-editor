// @flow

import DocsDataAttributes from './DocsDataAttributes';
import DocsDecoratorTypes from './DocsDecoratorTypes';
import asElement from './asElement';
import clearInlineFontStyles from './clearInlineFontStyles';
import convertImageElementToPlaceholderElement from './convertImageElementToPlaceholderElement';
import getCSSRules from './getCSSRules';
import getSafeDocumentElementFromHTML from './getSafeDocumentElementFromHTML';
import mergeCSSRuleStylesToElement from './mergeCSSRuleStylesToElement';
import uniqueID from './uniqueID';
import {CHAR_ZERO_WIDTH} from './DocsCharacter';

import type {DocumentLike} from './Types';
import type {CSSRules} from './getCSSRules';

export type SafeHTML = {
  html: string,
  unsafeNodes: Map<string, Node>,
  cssRules: CSSRules,
};

const DEPTH_CLASS_NAME_PATTERN = /(public-DraftStyleDefault-depth)(\d+)/;

function getSafeHTML(
  html: string,
  domDocument?: ?DocumentLike,
  defaultCSSRules?: ?CSSRules,
): SafeHTML {
  // This forces an extra space between consecutive <span />, which naively
  // fixes the problem of missing spacing between inline elements.
  html = html.replace(/<\/span><span/g, '</span> <span');

  const documentElement = getSafeDocumentElementFromHTML(html, domDocument);
  const body = documentElement ? documentElement.querySelector('body') : null;
  const ownerDocument: any = body && body.ownerDocument;
  const cssRules = defaultCSSRules || getCSSRules(ownerDocument);
  const unsafeNodes = new Map();
  let safeHTML = '';
  if (body) {
    // The provided chidlren nodes inside the atomic block should never be
    // rendered. Instead, the atomic block should only render with its entity
    // data. Therefore, move the children nodes into the quarantine pool
    // otherwise these chidlren wil be rendered as extra block after the atomic
    // block.
    const quarantine = (node) => {
      const id = uniqueID();
      node.id = id;
      unsafeNodes.set(id, node.cloneNode(true));
      node.setAttribute('data-quarantined-by-safe-html', id);
      node.innerHTML = CHAR_ZERO_WIDTH;
    };

    const atomicNodes = body.querySelectorAll(
      'figure[' + DocsDataAttributes.ATOMIC_BLOCK_DATA + ']',
    );
    Array.from(atomicNodes).forEach(quarantine);

    // Apply all linked CSS styles to element.
    Array.
      from(body.querySelectorAll('[class]')).
      forEach(mergeCSSRuleStylesToElement.bind(null, cssRules));

    const tableNodes = body.querySelectorAll('table');
    Array.from(tableNodes).forEach(quarantine);

    const mathNodes = body.querySelectorAll(
      'span[' +
      DocsDataAttributes.DECORATOR_TYPE + '="' +
      DocsDecoratorTypes.DOCS_MATH +
      '"]',
    );
    Array.from(mathNodes).forEach(quarantine);

    const imgNodes =  body.querySelectorAll('img');
    Array.from(imgNodes).forEach(convertImageElementToPlaceholderElement);

    // Monkey patch potentially nested lists.
    const listNodes = body.querySelectorAll('ul, ol');
    Array.from(listNodes).forEach(monkeyPatchListElementDepth);

    // Clear all font size inside headers.
    const headings = body.querySelectorAll('h1, h2, h3, h5, h6');
      Array.from(headings).forEach(clearInlineFontStyles);

    safeHTML = body.innerHTML;
  }

  return {
    cssRules,
    html: safeHTML,
    unsafeNodes,
  };
}


function monkeyPatchListElementDepth(el: Element): void {
  const listNodeName = el.nodeName;
  if (listNodeName !== 'UL' && listNodeName !== 'OL') {
    return;
  }

  Array.from(el.children).forEach(item => {
    const {nodeName, parentElement, style, className} = item;
    if (nodeName !== 'LI') {
      return;
    }

    let depth = 0;

    const {marginLeft} = style;
    if (marginLeft && marginLeft.indexOf('pt') > 0) {
      // This is just a workaround to deal with HTML generated by google doc.
      // Somehow in google doc, nested OL or UL elements may not be nested.
      // Instead, the nested UI / OL will noyt be nested and rendered with
      // margin-left. This function is to enforce the nested structure that can
      // be correctly parsed by draft-convert.
      const marginLeftPoints = Math.round(parseFloat(style.marginLeft));
      depth = Math.round(marginLeftPoints / 36);
    } else if (className) {
      const mm = className.match(DEPTH_CLASS_NAME_PATTERN);
      depth = mm && mm[2] ? parseInt(mm[2], 10) : 0;
    }

    if (!depth) {
      return;
    }
    const doc = item.ownerDocument;

    let currentEl = item;
    while (depth > 0) {
      const parentEl = el.cloneNode(false);
      parentEl.appendChild(currentEl);
      currentEl = parentEl;
      depth--;
    }
    if (currentEl !== item) {
      el.appendChild(currentEl);
    }
  });
}

export default getSafeHTML;
